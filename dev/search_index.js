var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#KJ.KJ","page":"API","title":"KJ.KJ","text":"KJ\n\nA Julia package to process LA-ICP-MS data\n\n\n\n\n\n","category":"module"},{"location":"api/#KJ.AbstractAnchor","page":"API","title":"KJ.AbstractAnchor","text":"AbstractAnchor\n\nAbstract base type for anchor point definitions in isotope ratio space.\n\nAnchor points represent known isotopic compositions of reference materials used for fractionation correction. Subtypes include IsochronAnchor, PointAnchor, and BiasAnchor.\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.AbstractBias","page":"API","title":"KJ.AbstractBias","text":"AbstractBias\n\nAbstract base type for mass bias correction parameters.\n\nSubtypes include Bias for standard isotope ratio bias and REEBias for rare earth element oxide bias corrections.\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.AbstractInterference","page":"API","title":"KJ.AbstractInterference","text":"AbstractInterference\n\nAbstract base type for interference correction specifications.\n\nSubtypes include Interference for general isobaric interferences and REEInterference for rare earth element oxide interferences.\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.AbstractRefmat","page":"API","title":"KJ.AbstractRefmat","text":"AbstractRefmat\n\nAbstract base type for reference material definitions.\n\nSubtypes include IsochronRefmat, PointRefmat, and BiasRefmat.\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Bias","page":"API","title":"KJ.Bias","text":"Bias <: AbstractBias\n\nMass bias correction parameters for isotope ratios.\n\nFields\n\nmass_num: Atomic mass of numerator isotope\nmass_den: Atomic mass of denominator isotope\npar: Vector of polynomial coefficients for bias correction\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Calibration","page":"API","title":"KJ.Calibration","text":"Calibration\n\nCalibration settings for mass bias correction.\n\nFields\n\nnum: Named tuple with numerator isotope (ion, channel)\nden: Named tuple with denominator isotope (ion, channel)\nstandards: Set of reference material names used for calibration\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Cfit","page":"API","title":"KJ.Cfit","text":"Cfit <: KJfit\n\nFitted parameters for concentration methods.\n\nFields\n\nblank: DataFrame of polynomial coefficients for blank corrections\npar: DataFrame of sensitivity factors for each element\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Cmethod","page":"API","title":"KJ.Cmethod","text":"Cmethod <: KJmethod\n\nConcentration method definition for quantitative element analysis.\n\nFields\n\nelements: Named tuple of elements to quantify\ngroups: Dictionary mapping group names to reference material names\ninternal: Tuple specifying internal standard (channel, concentration)\nnblank: Polynomial order for blank fitting\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Gfit","page":"API","title":"KJ.Gfit","text":"Gfit <: KJfit\n\nFitted parameters for geochronology methods.\n\nFields\n\nblank: DataFrame of polynomial coefficients for blank corrections\ndrift: Vector of drift correction parameters\ndown: Vector of downhole fractionation parameters\nadrift: Vector of analog mode drift parameters\ncovmat: Covariance matrix of fitted parameters\nbias: Dictionary of mass bias corrections by element\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Gmethod","page":"API","title":"KJ.Gmethod","text":"Gmethod <: KJmethod\n\nGeochronology method definition for parent-daughter isotope dating systems.\n\nFields\n\nname: Method name (e.g., \"U-Pb\", \"Rb-Sr\", \"Lu-Hf\", \"K-Ca\", \"Re-Os\")\ngroups: Dictionary mapping group names to reference material names\nP, D, d: Pairing definitions for parent, daughter, and normalizing isotopes\nbias: Calibration settings for mass bias correction\nstandards: Set of standard names used for fractionation correction\nnblank: Polynomial order for blank fitting (default: 2)\nndrift: Polynomial order for drift correction (default: 2)\nndown: Polynomial order for downhole fractionation (default: 1)\nnbias: Polynomial order for bias correction (default: 1)\nPAcutoff: Cutoff for analog vs counting mode (default: Inf)\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Interference","page":"API","title":"KJ.Interference","text":"Interference <: AbstractInterference\n\nInterference correction specification for isobaric interferences.\n\nFields\n\nproxy: Proxy isotope used to estimate the interference\nchannel: Channel being corrected for interference\nbias: Calibration object for any associated bias correction\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.KJfit","page":"API","title":"KJ.KJfit","text":"KJfit\n\nAbstract base type for fitted LA-ICP-MS correction parameters.\n\nSubtypes include:\n\nGfit: Fitted parameters for geochronology methods\nCfit: Fitted parameters for concentration methods\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.KJmethod","page":"API","title":"KJ.KJmethod","text":"KJmethod\n\nAbstract base type for LA-ICP-MS data reduction methods.\n\nSubtypes include:\n\nGmethod: Geochronology methods for parent-daughter isotope dating\nCmethod: Concentration methods for quantitative element analysis\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Pairing","page":"API","title":"KJ.Pairing","text":"Pairing\n\nIsotope pairing specification linking ions, proxies, and channels.\n\nFields\n\nion: Isotope notation (e.g., \"Pb206\")\nproxy: Proxy isotope used for calculations (defaults to ion)\nchannel: Measured channel name (defaults to proxy)\ninterferences: Dictionary of interference corrections to apply\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.REEBias","page":"API","title":"KJ.REEBias","text":"REEBias <: AbstractBias\n\nRare Earth Element oxide bias correction parameters.\n\nFields\n\npar: Vector of polynomial coefficients for bias correction\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.REEInterference","page":"API","title":"KJ.REEInterference","text":"REEInterference <: AbstractInterference\n\nRare Earth Element (REE) oxide interference correction specification.\n\nFields\n\nREE: REE element channel\nREEO: REE oxide channel\nstandards: Set of reference materials used for calibration\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Sample","page":"API","title":"KJ.Sample","text":"Sample\n\nRepresents a single LA-ICP-MS measurement.\n\nFields\n\nsname: Sample name\ndatetime: Acquisition date and time\ndat: DataFrame containing time-series measurements\nt0: Time of ablation onset (seconds)\nbwin: Vector of blank window tuples (startindex, endindex)\nswin: Vector of signal window tuples (startindex, endindex)\ngroup: Group label (e.g., \"sample\", standard name)\n\n\n\n\n\n","category":"type"},{"location":"api/#KJ.Calibration!-Tuple{Gmethod}","page":"API","title":"KJ.Calibration!","text":"Calibration!(method::Gmethod; standards=Set{String}())\n\nInitialize the calibration (bias correction) for a geochronology method.\n\nThis sets up the bias calibration structure using the sister/daughter isotope ratio, which will later be fitted using reference materials.\n\nArguments\n\nmethod: Geochronology method to set up calibration for\nstandards: Set of standard names to use for calibration (default: empty set)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.KJtree!-Tuple{AbstractDict}","page":"API","title":"KJ.KJtree!","text":"KJtree!(tree::AbstractDict)\n\nSet the KJ menu tree for the text user interface.\n\nArguments\n\ntree: Dictionary defining the TUI menu structure\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.KJtree-Tuple{}","page":"API","title":"KJ.KJtree","text":"KJtree()\n\nGet the current KJ menu tree.\n\nReturns\n\nDictionary containing the TUI menu structure\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.SS-Tuple{KJ.IsochronAnchor, AbstractVector, AbstractVector}","page":"API","title":"KJ.SS","text":"SS(a::AbstractAnchor, ft::AbstractVector, hT::AbstractVector; cruncher...)\nSS(par::AbstractVector, method::Gmethod, cruncher_groups::AbstractDict; verbose=false)\nSS(bias::AbstractBias; cruncher...)\n\nCalculate the sum of squares objective function for optimization.\n\nThis function computes the weighted sum of squared residuals between measured and predicted values, used for fitting fractionation corrections and bias terms.\n\nArguments\n\na/par: Anchor point or parameter vector\nft, hT: Fractionation factors (for anchor-based calls)\nmethod: Geochronology method (for parameter-based calls)\ncruncher/cruncher_groups: Data and covariances\nverbose: Print diagnostic information\n\nReturns\n\nSum of squared Mahalanobis distances\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.TUI-Tuple","page":"API","title":"KJ.TUI","text":"KJ(extensions...;logbook::AbstractString=\"\",reset=false)\n\nKJ TUI\n\nArguments\n\nextensions...: a comma separated list of KJ extensions\nlogbook: the file path to a KJ log\nreset: hard reset of all inherited settings\ndebug: whether to print the error stack trace when an error occurs (default: false)\n\nExamples\n\nTUI(logbook=\"logs/test.log\")\nctrl = getKJctrl()\nsamp = ctrl[\"run\"][1]\np = plot(samp)\ndisplay(p)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.atomic-Tuple{Sample, Gmethod, Gfit}","page":"API","title":"KJ.atomic","text":"atomic(samp::Sample, method::Gmethod, fit::Gfit; add_xy=false)\n\nCalculate atomic abundances (P, D, d) from measured signals.\n\nApplies all corrections (blank, interference, bias, fractionation) to convert raw signal intensities to corrected atomic abundances.\n\nArguments\n\nsamp: Sample to process\nmethod: Geochronology method definition\nfit: Fitted correction parameters\nadd_xy: Include x,y spatial coordinates if available (default: false)\n\nReturns\n\nNamed tuple with fields P (parent), D (daughter), d (sister/normalizing isotope), and optionally x, y coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.averat-Tuple{Vector{Sample}, Gmethod, Gfit}","page":"API","title":"KJ.averat","text":"averat(run::Vector{Sample}, method::Gmethod, fit::Gfit)\naverat(samp::Sample, method::Gmethod, fit::Gfit)\n\nCalculate average ratios for samples using a weighted mean approach.\n\nArguments\n\nrun/samp: Vector of samples or single sample\nmethod: Geochronology method definition\nfit: Fitted fractionation and blank parameters\n\nReturns\n\nDataFrame with columns: name, P/D ratio, uncertainty, d/D ratio, uncertainty, ρ (for run) or array of [P/D, s[P/D], d/D, s[d/D], ρ] values (for single sample)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.blank!-Tuple{KJfit, KJmethod, Vector{Sample}}","page":"API","title":"KJ.blank!","text":"blank!(fit::KJfit, method::KJmethod, run::Vector{Sample})\n\nFit blank corrections for a run.\n\nExtracts data from blank windows and fits polynomial background models for each channel.\n\nArguments\n\nfit: Fit object to populate with blank parameters\nmethod: Method definition\nrun: Vector of samples\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.blocks-Tuple{Vector{Sample}, Integer}","page":"API","title":"KJ.blocks","text":"blocks(run::Vector{Sample}, blocksize::Integer; absolute_buffer=2.0, relative_buffer=0.1)\n\nSplit a run into blocks of a given size and merge the samples within each block.\n\nArguments\n\nrun: Vector of samples to divide into blocks\nblocksize: Number of samples per block\nabsolute_buffer: Absolute time buffer for automatic window selection (default: 2.0 seconds)\nrelative_buffer: Relative time buffer for automatic window selection (default: 0.1)\n\nReturns\n\nVector of merged samples, one per block\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.bwinData-Tuple{Sample}","page":"API","title":"KJ.bwinData","text":"bwinData(samp::Sample; add_xy=false)\n\nExtract data from the blank window of a sample.\n\nArguments\n\nsamp: Sample to extract data from\nadd_xy: If true, include x,y coordinates if available\n\nReturns\n\nDataFrame containing the windowed data\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.calculate_subset_stats-Tuple{AbstractMatrix, Vector{Int64}}","page":"API","title":"KJ.calculate_subset_stats","text":"calculatesubsetstats(X, indices)\n\nCalculates the mean, covariance matrix, and its  determinant for a given subset of data.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.concentration_step-Tuple{AbstractMatrix, Int64, Any, Any}","page":"API","title":"KJ.concentration_step","text":"concentrationstep(X, h, currentmu, current_Sigma)\n\nThe core C-Step. It finds the h observations closest to the current center (mu) based on the Mahalanobis distance derived from the current scatter matrix (Sigma).\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.concentrations-Tuple{Sample, Cmethod, Cfit}","page":"API","title":"KJ.concentrations","text":"concentrations(samp::Sample, method::Cmethod, fit::Cfit; internal=method.internal)\nconcentrations(run::Vector{Sample}, method::Cmethod, fit::Cfit)\n\nCalculate element concentrations from calibrated LA-ICP-MS data.\n\nFor single samples, returns time-resolved concentrations for each element. For runs, returns summary statistics (mean ± standard error) for each sample.\n\nArguments\n\nsamp/run: Sample or vector of samples\nmethod: Concentration method with element definitions and internal standard\nfit: Fitted sensitivity factors\ninternal: Internal standard as (channel, concentration) tuple\n\nReturns\n\nDataFrame with concentration values. For single samples, includes time-resolved data and optional x,y coordinates. For runs, includes sample names, means, and standard errors.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.detect_outliers!-Tuple{Vector{Sample}}","page":"API","title":"KJ.detect_outliers!","text":"detect_outliers!(run::Vector{Sample}; channels=getChannels(run), include_samples=false)\ndetect_outliers!(run::Vector{Sample}, method::KJmethod; include_samples=false)\n\nDetect and flag outliers in a run of samples (in-place modification).\n\nSets the outlier column in each sample's data frame to true for detected outliers.\n\nArguments\n\nrun: Vector of samples to process\nchannels/method: Channels to use for outlier detection, or method from which to extract channels\ninclude_samples: If true, also detect outliers in samples (not just standards)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.detect_outliers-Tuple{AbstractVector}","page":"API","title":"KJ.detect_outliers","text":"detect_outliers(vec::AbstractVector; b=2)\ndetect_outliers(mat::Matrix; b=2)\n\nDetect outliers in time-series data using a moving median approach.\n\nFor vectors, uses interquartile range (IQR) criterion on deviations from moving median. For matrices, uses Mahalanobis distance and minimum covariance determinant (MCD).\n\nArguments\n\nvec/mat: Time-series data as vector or matrix\nb: Bandwidth for moving median (default: 2)\n\nReturns\n\nVector of indices where outliers are detected\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.df2cov-Tuple{DataFrames.AbstractDataFrame}","page":"API","title":"KJ.df2cov","text":"function df2cov(df::AbstractDataFrame)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.df2cov-Tuple{Matrix}","page":"API","title":"KJ.df2cov","text":"df2cov(mat::Matrix)\n\nEstimate the covariance matrix of mat's columns from its differenced rows.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.export2IsoplotR-Tuple{Vector{Sample}, Gmethod, Gfit}","page":"API","title":"KJ.export2IsoplotR","text":"export2IsoplotR(run::Vector{Sample}, method::Gmethod, fit::Gfit; prefix=nothing, fname=\"KJ.json\")\nexport2IsoplotR(ratios::AbstractDataFrame, method::Gmethod; fname=\"KJ.json\")\n\nExport processed data to IsoplotR JSON format.\n\nArguments\n\nrun: Vector of samples to export\nratios: Pre-computed ratio data frame\nmethod: Geochronology method\nfit: Fitted parameters (for first method)\nprefix: Optional prefix to filter samples (default: export all)\nfname: Output filename (default: \"KJ.json\")\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.fast_mcd-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"API","title":"KJ.fast_mcd","text":"fastmcd(X::AbstractMatrix; h::Int=0, numstarts::Int=500, maxcsteps::Int=10)\n\nImplements the FAST-MCD algorithm using randomized starts and concentration steps.\n\nArguments\n\nX: The data matrix (observations as rows, features as columns).\nh: The size of the subset. Defaults to floor((n + p + 1) / 2) for max robustness.\nnum_starts: Number of random initial subsets to check.\nmax_c_steps: Maximum number of C-steps per start before declaring convergence.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.fitBlanks-Tuple{Vector{Sample}}","page":"API","title":"KJ.fitBlanks","text":"fitBlanks(run::Vector{Sample}; nblank=2)\n\nFit polynomial blank models to blank window data.\n\nArguments\n\nrun: Vector of samples\nnblank: Order of polynomial (default: 2 for quadratic)\n\nReturns\n\nDataFrame of polynomial coefficients for each channel\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.fit_bias-Tuple{Vector{Sample}, Gmethod, DataFrames.AbstractDataFrame}","page":"API","title":"KJ.fit_bias","text":"fit_bias(run::Vector{Sample}, method::Gmethod, blank::AbstractDataFrame)\n\nFit mass bias corrections for isotope ratios.\n\nIdentifies and corrects for systematic bias in isotope ratio measurements using reference materials with known ratios.\n\nArguments\n\nrun: Vector of samples including reference materials\nmethod: Geochronology method definition\nblank: Fitted blank corrections\n\nReturns\n\nDictionary mapping elements to Bias objects containing correction parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.fractionation!-Tuple{Cfit, Cmethod, Vector{Sample}}","page":"API","title":"KJ.fractionation!","text":" Cs  sum(S_i X_i)\n\n[f = – –––––––]      C    sum(S_i^2)\n\nwith C, Cs = reference concentrations of the elements and internal standard      Xi, Si = blank-corrected measurement for elements and internal standard\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.fractionation!-Tuple{Gfit, Gmethod, Vector{Sample}}","page":"API","title":"KJ.fractionation!","text":"fractionation!(fit::Gfit, method::Gmethod, run::Vector{Sample}; verbose=false)\nfractionation!(fit::Cfit, method::Cmethod, run::Vector{Sample}; kwargs...)\n\nFit drift and downhole fractionation corrections.\n\nFor geochronology methods (Gmethod), fits polynomial time-dependent drift and downhole corrections using reference materials. For concentration methods (Cmethod), fits sensitivity factors using internal standards.\n\nArguments\n\nfit: Fit object to populate with fractionation parameters\nmethod: Method definition\nrun: Vector of samples\nverbose: Print detailed optimization information (default: false)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getAnchor-Tuple{AbstractString, AbstractString}","page":"API","title":"KJ.getAnchor","text":"getAnchor(methodname::AbstractString, refmat::AbstractString)\ngetAnchor(standard::AbstractRefmat; methodname::AbstractString)\n\nGet the anchor coordinates for a reference material.\n\nAnchor points represent the known composition of reference materials in isotope ratio space, used for fractionation correction.\n\nArguments\n\nmethodname: Name of geochronology method (e.g., \"U-Pb\", \"Rb-Sr\")\nrefmat/standard: Reference material name or object\n\nReturns\n\nAnchor object (IsochronAnchor, PointAnchor, or BiasAnchor)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getChannels-Tuple{Vector{Sample}}","page":"API","title":"KJ.getChannels","text":"getChannels(run::Vector{Sample})\ngetChannels(samp::Sample)\ngetChannels(interference::Interference)\ngetChannels(method::Gmethod)\ngetChannels(method::Cmethod)\n\nGet the names of all channels from samples, methods, or interferences.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getGroups-Tuple{Vector{Sample}}","page":"API","title":"KJ.getGroups","text":"getGroups(run::Vector{Sample})\n\nGet a vector of group labels from a run.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getIndicesInGroup-Tuple{Vector{Sample}, AbstractString}","page":"API","title":"KJ.getIndicesInGroup","text":"getIndicesInGroup(run::Vector{Sample}, group::AbstractString)\n\nFind the indices of all samples in a run that belong to a specific group.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getInternal-Tuple{AbstractString, AbstractString}","page":"API","title":"KJ.getInternal","text":"getInternal(mineral::AbstractString,             channel::AbstractString)\n\nGet a tuple with the channel and its reference concentration\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getKJctrl-Tuple{}","page":"API","title":"KJ.getKJctrl","text":"getKJctrl()\n\nAccess the control parameters of a TUI session.\n\nReturns\n\nDictionary containing TUI control parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getP-Tuple{KJ.IsochronAnchor, AbstractVector, AbstractVector}","page":"API","title":"KJ.getP","text":"getP(a::IsochronAnchor, ft::AbstractVector, hT::AbstractVector; cruncher...)\n\nCalculate the parent isotope abundances for an isochron anchor.\n\nThis is a low-level function used internally for geochronological calculations.\n\nArguments\n\na: Isochron anchor point\nft: Time-dependent fractionation factor\nhT: Downhole fractionation factor\ncruncher...: Named tuple containing measured data and covariances\n\nReturns\n\nVector of parent isotope abundances\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getPDd-Tuple{AbstractString}","page":"API","title":"KJ.getPDd","text":"getPDd(method::AbstractString)\n\nGet the names of the parent, daughter and sister channel\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.getSignals-Tuple{Sample}","page":"API","title":"KJ.getSignals","text":"getSignals(samp::Sample)\n\nReturns a dataframe with signals (no time, coordinates or outliers)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.geti0-Tuple{DataFrames.AbstractDataFrame}","page":"API","title":"KJ.geti0","text":"geti0(signals::AbstractDataFrame)\n\nGet the index of 'time zero', i.e. the onset of laser ablation.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.i2t-Tuple{Sample, Integer}","page":"API","title":"KJ.i2t","text":"i2t(samp::Sample,i::Integer)\n\nReturns the time at index t\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.interference_correction-Tuple{DataFrames.AbstractDataFrame, AbstractDict}","page":"API","title":"KJ.interference_correction","text":"interference_correction(dat::AbstractDataFrame, interferences::AbstractDict; bias=Dict(), blank=DataFrame())\ninterference_correction(dat::AbstractDataFrame, ion::AbstractString, interference::Interference; bias=Dict(), blank=DataFrame())\ninterference_correction(dat::AbstractDataFrame, proxy_channel::AbstractString, interference::REEInterference; bias=Dict(), blank=DataFrame())\n\nApply interference corrections to measured data.\n\nArguments\n\ndat: DataFrame containing measured data with a time column\ninterferences: Dictionary of interferences to correct for, or a single ion/channel and interference\nbias: Optional dictionary of bias corrections\nblank: Optional DataFrame with blank corrections\n\nReturns\n\nVector of interference-corrected values\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.internochron-Tuple{Vector{Sample}, Gmethod, Gfit}","page":"API","title":"KJ.internochron","text":"internochron(run::Vector{Sample}, method::Gmethod, fit::Gfit)\ninternochron(samp::Sample, method::Gmethod, fit::Gfit)\n\nCalculate internal isochron (\"internochron\") coordinates for samples.\n\nFor geochronology methods, this fits an isochron through the time-resolved data of each sample, returning the intercept coordinates (x0, y0) along with their uncertainties and correlation.\n\nArguments\n\nrun/samp: Vector of samples or single sample\nmethod: Geochronology method definition\nfit: Fitted fractionation and blank parameters\n\nReturns\n\nDataFrame with columns: name, x0, s[x0], y0, s[y0], ρ (for run) or array of [x0, s[x0], y0, s[y0], ρ] values (for single sample)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.internoplot-Tuple{Sample, Gmethod, Gfit}","page":"API","title":"KJ.internoplot","text":"internoplot(samp::Sample, method::Gmethod, fit::Gfit; legend=false, nsigma=2, title=..., titlefontsize=10, plot_options...)\n\nCreate an isochron plot for internal isochron data from a single sample.\n\nArguments\n\nsamp: Sample to plot\nmethod: Geochronology method definition\nfit: Fitted fractionation and blank parameters\nlegend: Show legend (default: false)\nnsigma: Number of standard deviations for error envelope (default: 2)\ntitle: Plot title\ntitlefontsize: Font size for title (default: 10)\nplot_options...: Additional plotting options\n\nReturns\n\nPlots.jl plot object\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.iratio-Tuple{AbstractString, AbstractString}","page":"API","title":"KJ.iratio","text":"iratio(nuclide1::AbstractString, nuclide2::AbstractString)\n\nGet the isotope ratio between two nuclides.\n\nArguments\n\nnuclide1: Name of the numerator nuclide (e.g., \"U238\")\nnuclide2: Name of the denominator nuclide (e.g., \"U235\")\n\nReturns\n\nThe isotope ratio, or nothing if not found in the database\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.load-Tuple{AbstractString}","page":"API","title":"KJ.load","text":"load(dname::AbstractString; format=\"Agilent\", head2name=true, nblocks=1, absolute_buffer=2.0, relative_buffer=0.1)\nload(dfile::AbstractString, tfile::AbstractString; format=\"Agilent\")\n\nLoad LA-ICP-MS data from files.\n\nThe first method loads all files from a directory, sorts them by acquisition time, and optionally merges them into blocks. The second method loads a single data file with associated timestamps.\n\nArguments\n\ndname/dfile: Directory containing data files, or path to a single data file\ntfile: Path to timestamp file (for second method)\nformat: File format - \"Agilent\", \"ThermoFisher\", or \"FIN2\" (default: \"Agilent\")\nhead2name: Use file header for sample name (default: true)\nnblocks: Number of blocks to merge samples into (default: 1, no merging)\nabsolute_buffer: Absolute time buffer for automatic window selection (default: 2.0 seconds)\nrelative_buffer: Relative time buffer for automatic window selection (default: 0.1)\n\nReturns\n\nVector of Sample objects\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.moving_median_indices-Tuple{Int64}","page":"API","title":"KJ.moving_median_indices","text":"moving_median_indices(n::Int; b=2)\n\nGenerate index matrix for moving median calculation.\n\nArguments\n\nn: Length of the time series\nb: Bandwidth (default: 2)\n\nReturns\n\nMatrix of indices where each row contains the indices for computing the moving median at that position\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.plot-Tuple{Sample, KJmethod}","page":"API","title":"KJ.plot","text":"plot(samp::Sample, method::KJmethod; channels=getChannels(method), fit=nothing, num=\"\", den=\"\", transformation=\"\", ...)\nplot(samp::Sample; channels=getChannels(samp), num=\"\", den=\"\", transformation=\"\", offset=..., ...)\n\nPlot time-resolved LA-ICP-MS data for a sample.\n\nDisplays signal intensities vs time with blank and signal windows marked. Optionally overlays fitted corrections if a fit object is provided.\n\nArguments\n\nsamp: Sample to plot\nmethod: Method definition (optional, for determining channels and fit)\nchannels: Channels to display\nfit: Fitted corrections to overlay (optional)\nnum, den: Numerator/denominator for ratio plots (default: plot raw signals)\ntransformation: Apply transformation (\"log\", \"sqrt\", or \"\")\nxlim, ylim: Plot limits\ntitle: Plot title\nlegend: Legend position\ncpalette: Color palette\nms, ma: Marker size and alpha\nAdditional plotting options\n\nReturns\n\nPlots.jl plot object\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.plotFitted!-Tuple{Any, Sample, KJmethod, KJfit}","page":"API","title":"KJ.plotFitted!","text":"plotFitted!(p, samp::Sample, method::KJmethod, fit::KJfit; channels=..., num=\"\", den=\"\", transformation=\"\", offset=0.0, linecolor=:black, linestyle=:solid)\n\nOverlay fitted signal predictions on an existing plot.\n\nArguments\n\np: Existing plot to overlay on\nsamp: Sample being plotted\nmethod: Method definition\nfit: Fit object with correction parameters\nAdditional arguments control what is plotted and how it appears\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.plotFittedBlank!-Tuple{Any, Sample, KJmethod, KJfit}","page":"API","title":"KJ.plotFittedBlank!","text":"plotFittedBlank!(p, samp::Sample, method::KJmethod, fit::KJfit; channels=..., num=\"\", den=\"\", transformation=\"\", offset=0.0, linecolor=:black, linestyle=:solid)\n\nOverlay fitted blank predictions on an existing plot.\n\nArguments\n\np: Existing plot to overlay on\nsamp: Sample being plotted\nmethod: Method definition\nfit: Fit object with blank parameters\nAdditional arguments control what is plotted and how it appears\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.plotMap-Tuple{DataFrames.AbstractDataFrame, AbstractString}","page":"API","title":"KJ.plotMap","text":"plotMap(df::AbstractDataFrame, column::AbstractString; clims=(), markersize=2, markershape=:square, colorbar_scale=:log10, aspect_ratio=:equal, color=:viridis, ignore_negative=false)\n\nCreate a spatial map visualization of a data column.\n\nRequires that the DataFrame contains x and y coordinate columns.\n\nArguments\n\ndf: DataFrame containing data with x, y coordinates\ncolumn: Column name to visualize\nclims: Color scale limits (optional)\nmarkersize: Size of map points (default: 2)\nmarkershape: Shape of markers (default: :square)\ncolorbar_scale: Scale for colorbar, typically :log10 or :identity (default: :log10)\naspect_ratio: Plot aspect ratio (default: :equal)\ncolor: Color palette (default: :viridis)\nignore_negative: Exclude negative values from plot (default: false)\n\nReturns\n\nPlots.jl plot object, or nothing if x,y coordinates are missing\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.polyFac-Tuple{AbstractVector, AbstractVector}","page":"API","title":"KJ.polyFac","text":"polyFac(p::AbstractVector, t::AbstractVector)\n\nEvaluate exponential of polynomial with parameters p at times t. Returns exp(p[1] + p[2]t + p[3]t^2 + ...).\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.polyVal-Tuple{AbstractVector, AbstractVector}","page":"API","title":"KJ.polyVal","text":"polyVal(p::AbstractVector,t::AbstractVector)\n\nEvaluates polynomial function with parameters p at times t.\n\nArguments\n\np: Vector of polynomial coefficients [p0, p1, p2, ...] representing p0 + p1t + p2t^2 + ...\nt: Vector of time values at which to evaluate the polynomial\n\nReturns\n\nVector of polynomial values at each time point\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.polyVal-Tuple{DataFrames.AbstractDataFrame, AbstractVector}","page":"API","title":"KJ.polyVal","text":"polyVal(p::AbstractDataFrame,t::AbstractVector)\n\nEvaluates polynomial functions (one per column) at times t.\n\nArguments\n\np: DataFrame where each column contains polynomial coefficients\nt: Vector of time values at which to evaluate polynomials\n\nReturns\n\nDataFrame with polynomial values, one column per input column\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.predict-Tuple{Sample, Gmethod, Gfit}","page":"API","title":"KJ.predict","text":"predict(samp::Sample, method::Union{Gmethod,Cmethod}, fit::Union{Gfit,Cfit}; generic_names=true)\npredict(samp::Sample, blank::AbstractDataFrame)\n\nPredict signal intensities for a sample given fitted parameters.\n\nCalculates expected signal values based on fractionation model, anchor points, and bias corrections. Used for model checking and plotting fitted curves.\n\nArguments\n\nsamp: Sample to predict for\nmethod: Method definition\nfit: Fitted parameters\nblank: Blank fit (for blank prediction)\ngeneric_names: Use generic column names (P, D, d) vs specific isotopes (default: true)\n\nReturns\n\nDataFrame with predicted signals\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.prefix2subset-Tuple{DataFrames.AbstractDataFrame, AbstractString}","page":"API","title":"KJ.prefix2subset","text":"prefix2subset(ratios::AbstractDataFrame,prefix::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.prefix2subset-Tuple{Vector{Sample}, AbstractString}","page":"API","title":"KJ.prefix2subset","text":"prefix2subset(run::Vector{Sample},prefix::AbstractString)\n\nSubset selected samples from run.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.prep_plot-Tuple{Sample, AbstractVector}","page":"API","title":"KJ.prep_plot","text":"prep_plot(samp::Sample, channels; offset=0.0, num=\"\", den=\"\", transformation=\"\")\n\nPrepare data for plotting by extracting signals and applying transformations.\n\nArguments\n\nsamp: Sample to extract data from\nchannels: Channels to include\noffset: Offset to add before transformation\nnum, den: For ratio plots\ntransformation: Transformation to apply\n\nReturns\n\nTuple of (x, y, xlab, ylab) where x is time, y is DataFrame of processed signals\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.process!-Tuple{Vector{Sample}, KJmethod}","page":"API","title":"KJ.process!","text":"process!(run::Vector{Sample}, method::KJmethod; setGroup=true, reject_outliers=true, verbose=false)\n\nProcess a complete run of LA-ICP-MS data.\n\nThis function performs the full data reduction workflow:\n\nAssign group labels to samples based on the method (if setGroup=true)\nDetect and flag outliers (if reject_outliers=true)\nInitialize a KJfit object\nFit blank corrections\nFit bias corrections (for Gmethod)\nFit drift and downhole fractionation corrections\n\nArguments\n\nrun: Vector of samples to process\nmethod: Geochronology or concentration method definition\nsetGroup: Whether to assign group labels before fitting (default: true)\nreject_outliers: Whether to automatically detect and flag outliers (default: true)\nverbose: Print detailed diagnostic information (default: false)\n\nReturns\n\nFitted KJfit object containing all correction parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.rle-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"API","title":"KJ.rle","text":"rle(v)\n\nReturn the run-length encoding of a vector as a tuple.\n\nFunction lifted from StatsBase.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.setBwin!-Tuple{Vector{Sample}, AbstractVector}","page":"API","title":"KJ.setBwin!","text":"setBwin!(run::Vector{Sample}, bwin::AbstractVector; seconds=false)\nsetBwin!(samp::Sample, bwin::AbstractVector; seconds=false)\nsetBwin!(run::Vector{Sample})\nsetBwin!(samp::Sample)\n\nSet the blank window (bwin) for one or more samples.\n\nIf bwin is provided, it is directly set (as indices or time in seconds if seconds=true). If no bwin is provided, an automatic blank window is calculated.\n\nArguments\n\nrun/samp: Vector of samples or single sample\nbwin: Window specification (optional)\nseconds: If true, interpret window as time in seconds; otherwise as indices\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.setGroup!-Tuple{Vector{Sample}, KJmethod}","page":"API","title":"KJ.setGroup!","text":"setGroup!(run::Vector{Sample}, method::KJmethod)\nsetGroup!(run::Vector{Sample}, selection, group::AbstractString)\nsetGroup!(run::Vector{Sample}, prefixes::Vector{String})\n\nSet the group labels for samples in a run, either from a method definition, by selecting specific sample indices, or by matching prefixes in sample names.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.setKJctrl!-Tuple{AbstractDict}","page":"API","title":"KJ.setKJctrl!","text":"setKJctrl!(ctrl::AbstractDict)\n\nSet the control parameters of a TUI session.\n\nArguments\n\nctrl: Dictionary of control parameters to set\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.setSwin!-Tuple{Vector{Sample}, AbstractVector}","page":"API","title":"KJ.setSwin!","text":"setSwin!(run::Vector{Sample}, swin::AbstractVector; seconds=false)\nsetSwin!(samp::Sample, swin::AbstractVector; seconds=false)\nsetSwin!(run::Vector{Sample})\nsetSwin!(samp::Sample)\n\nSet the signal window (swin) for one or more samples.\n\nIf swin is provided, it is directly set (as indices or time in seconds if seconds=true). If no swin is provided, an automatic signal window is calculated.\n\nArguments\n\nrun/samp: Vector of samples or single sample\nswin: Window specification (optional)\nseconds: If true, interpret window as time in seconds; otherwise as indices\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.sett0!-Tuple{Sample, Number}","page":"API","title":"KJ.sett0!","text":"sett0!(samp::Sample,        t0::Number)\n\nManually set time zero for a single sample\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.sett0!-Tuple{Sample}","page":"API","title":"KJ.sett0!","text":"sett0!(samp::Sample)\n\nAutomatically set time zero for a single sample.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.sett0!-Tuple{Vector{Sample}, Number}","page":"API","title":"KJ.sett0!","text":"sett0!(run::Vector{Sample},        t0::Number)\n\nManually set time zero for an entire run.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.sett0!-Tuple{Vector{Sample}}","page":"API","title":"KJ.sett0!","text":"sett0!(run::Vector{Sample})\n\nAutomatically set time zero, i.e. the onset of laser ablation.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.shift_windows!","page":"API","title":"KJ.shift_windows!","text":"shift_windows!(run::Vector{Sample}, shift::Number=0.0)\n\nShift both blank and signal windows for all samples in a run by a given time offset.\n\nArguments\n\nrun: Vector of samples\nshift: Time shift in seconds (default: 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#KJ.summarise-Tuple{Gfit}","page":"API","title":"KJ.summarise","text":"summarise(fit::Gfit)\n\nPrint a summary of fitted parameters from a Gfit object.\n\nDisplays drift corrections, down-hole fractionation factors, elemental drift corrections, the covariance matrix, and bias parameters for each element.\n\nArguments\n\nfit: A Gfit object containing fitted calibration parameters\n\nReturns\n\nNothing. Output is printed to stdout.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.summarise-Tuple{Vector{Sample}}","page":"API","title":"KJ.summarise","text":"summarise(run::Vector{Sample}; verbose=true, n=length(run))\n\nCreate a summary DataFrame of samples with their names, acquisition dates, and group assignments.\n\nArguments\n\nrun: Vector of Sample objects to summarize\nverbose: If true, print the first n rows of the summary (default: true)\nn: Number of rows to display when verbose is true (default: length(run))\n\nReturns\n\nDataFrame with columns: name, date, and group for each sample\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.summarize-Tuple{Gfit}","page":"API","title":"KJ.summarize","text":"summarize(fit::Gfit)\n\nAmerican spelling alias for summarise. See summarise for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.summarize-Tuple{Vector{Sample}}","page":"API","title":"KJ.summarize","text":"summarize(run::Vector{Sample}; verbose=true, n=length(run))\n\nAmerican spelling alias for summarise. See summarise for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.swinData-Tuple{Sample}","page":"API","title":"KJ.swinData","text":"swinData(samp::Sample; add_xy=false)\n\nExtract data from the signal window of a sample.\n\nThe returned data includes a T column with relative time in minutes from t0. If x,y coordinates are available and add_xy=true, they are also included.\n\nArguments\n\nsamp: Sample to extract data from\nadd_xy: If true, include x,y coordinates if available\n\nReturns\n\nDataFrame containing the windowed data with time column T in minutes\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.t2i-Tuple{Sample, Number}","page":"API","title":"KJ.t2i","text":"t2i(samp::Sample,t::Number)\n\nReturns the index of time t in sample samp.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.time2window-Tuple{Sample, AbstractVector}","page":"API","title":"KJ.time2window","text":"time2window(samp::Sample,twin::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.time2window-Tuple{Sample, Number, Number}","page":"API","title":"KJ.time2window","text":"time2window(samp::Sample,start::Number,finish::Number)\n\nReturns a tuple or a vector of tuples with the indices corresponding to the start and finish times.\n\n\n\n\n\n","category":"method"},{"location":"api/#KJ.var_timeseries-Tuple{AbstractVector}","page":"API","title":"KJ.var_timeseries","text":"var_timeseries(cps::AbstractVector)\n\nEstimate the variance of the differenced vector cps. Returns a vector of replicate values.\n\n\n\n\n\n","category":"method"},{"location":"tui/#Text-Based-User-Interface-(TUI)","page":"TUI","title":"Text-Based User Interface (TUI)","text":"The TUI provides an interactive, menu-driven workflow for loading data, defining methods, processing analyses, and exporting results.","category":"section"},{"location":"tui/#Start-the-TUI","page":"TUI","title":"Start the TUI","text":"using KJ\nTUI()","category":"section"},{"location":"tui/#Example-Session-(Menu-Driven)","page":"TUI","title":"Example Session (Menu-Driven)","text":"julia> using KJ\njulia> TUI()\n----------\n KJ 0.8.2\n----------\n\nr: Read data files[*]\nm: Specify the method[*]\nt: Tabulate the samples\nv: View and adjust each sample\ni: Interferences\nf: Fractionation[*]\nb: Mass bias\np: Process the data[*]\ne: Export the results\nl: Logs and templates\no: Options\nu: Update\nc: Clear\na: Extra\nx: Exit\n?: Help\nr\n\na: csv (Agilent)\nt: csv (ThermoFisher)\nf: FIN2\nx: Exit\n?: Help\na\n\nd: Read a directory in which analysis is stored in a different file\nb: Set the number of blocks per analysis (current value = 1)\np: Parse the data from a single file using a laser log (provide paths)\nP: Parse the data from a single file using a laser log (choose from list)\nx: Exit\n?: Help\nd\n\nEnter the full path of the data directory (? for help, x to exit):\ndata/Lu-Hf\n\nr: Read data files\nm: Specify the method[*]\nt: Tabulate the samples\nv: View and adjust each sample\ni: Interferences\nf: Fractionation[*]\nb: Mass bias\np: Process the data[*]\ne: Export the results\nl: Logs and templates\no: Options\nu: Update\nc: Clear\na: Extra\nx: Exit\n?: Help\nv\n\n(Image: Example plot)","category":"section"},{"location":"tui/#Logs-and-Templates","page":"TUI","title":"Logs and Templates","text":"The TUI includes a built-in system for saving session logs and reusable templates. These are accessed from the main menu via l: Logs and templates. A KJ log is a text file that records all the key strokes of a TUI session. For example, the log for the previous section looks like this:\n\ntask,action\ntop,r\nformat,a\ndir|file,d\nloadICPdir,data/Lu-Hf\ntop,v\nview,x","category":"section"},{"location":"tui/#Export-a-Session-Log","page":"TUI","title":"Export a Session Log","text":"Use logs to save a processing session and replay it later:\n\nFrom the main menu, press l.\nChoose e: Export the session log.\nEnter a file path, e.g. logs/Lu-Hf.log.\n\nYou can then replay the session with:\n\nTUI(logbook=\"logs/Lu-Hf.log\")\n\nAlternatively, you can also continue a previous session from within the TUI:\n\nPress l.\nChoose i: Import a session log.\nProvide the path to the saved log file.","category":"section"},{"location":"tui/#Save-a-Template","page":"TUI","title":"Save a Template","text":"Templates store default settings (format, method definition, transformations, and other defaults) in a Julia script so you can avoid re-entering them.\n\nPress l.\nChoose s: Save a template.\nProvide a path such as templates/Lu-Hf.tmp.\n\nExample template file:\n\nformat = \"Agilent\"\nmultifile = true\nhead2name = true\ntransformation = \"log\"\nnblocks = 1\nmethod = Gmethod(name=\"Lu-Hf\",\n                 P=Pairing(ion=\"Lu176\", proxy=\"Lu175\", channel=\"Lu175 -> 175\"),\n                 D=Pairing(ion=\"Hf176\", proxy=\"Hf176\", channel=\"Hf176 -> 258\"),\n                 d=Pairing(ion=\"Hf177\", proxy=\"Hf178\", channel=\"Hf178 -> 260\"),\n                 nblank=2,\n                 ndrift=2,\n                 ndown=1,\n                 PAcutoff=1.0e7)\nmethod.groups = Dict(\"hogsbo\" => \"Hogsbo\", \"NIST612p\" => \"NIST612\")\nmethod.standards = Set([\"hogsbo\"])","category":"section"},{"location":"tui/#Open-a-Template","page":"TUI","title":"Open a Template","text":"To apply a template during a session:\n\nPress l.\nChoose o: Open a template.\nProvide the path to the template file.","category":"section"},{"location":"tui/#Extensions","page":"TUI","title":"Extensions","text":"The TUI uses a decision tree that is saved as a Dict. Extensions are Julia packages that modify this Dict to alter the default behaviour of the TUI. Extensions can be used to add or remove branches of TUI tree, or to swap out functions. KJgui is a proof-of-concept example of a simple extension, which adds GUI elements to the TUI, including interactive file choosers. This extension can be obtained from https://github.com/pvermees/KJgui.jl and used as follows:\n\njulia> using KJ, KJgui\njulia> TUI(KJgui)\n\nFor detailed function documentation, see the API reference.","category":"section"},{"location":"repl/#Examples-(REPL)","page":"REPL","title":"Examples (REPL)","text":"Advanced users can interact directly with KJ via the Julia REPL (\"read-eval-print loop\") for maximum flexibility and control over data processing pipelines.","category":"section"},{"location":"repl/#Loading-Data","page":"REPL","title":"Loading Data","text":"Some labs prefer to store each analysis in a separate data file. Others prefer to put all analyses into a single file, which is parsed into chunks according to a separately provided laser log file. A third option is to divide each analysis into several files corresponding to background, signal and washout, respectively. Sample names are either stored in the data files, or have to be derived from the file names. KJ accommodates all these methods of operation. They are illustrated here with example data files that are packaged with the software.\n\nLoad LA-ICP-MS data from a directory of .csv files from an Agilent instrument:\n\nusing KJ\nLuHf_run = load(\"data/Lu-Hf\"; format=\"Agilent\")\nReOs_run = load(\"data/Re-Os\"; format=\"Agilent\")\nKCa_run = load(\"data/K-Ca\"; format=\"Agilent\")\n\nLoad data in a ThermoFisher format:\n\niCap_run = load(\"data/iCap\"; format=\"ThermoFisher\")\n\nLoad UPb data with sample names extracted from file names:\n\nUPb_run = load(\"data/U-Pb\"; format=\"Agilent\", head2name=false)\n\nLoad data from a Neptune MC-ICP-MS with background, signal and washout split in different files:\n\nMC_run = load(\"data/FIN2\"; format=\"FIN2\", nblocks=3)\n\nLoad data from one massive .csv file with timestamps provided in a separate laser log file:\n\nmap_run = load(\"data/timestamp/NHM_data.csv\",\n               \"data/timestamp/NHM_timestamps.csv\";\n               format=\"Agilent\")","category":"section"},{"location":"repl/#View-a-summary-of-the-loaded-data","page":"REPL","title":"View a summary of the loaded data","text":"Show all the samples in a run:\n\nsummarise(UPb_run)","category":"section"},{"location":"repl/#Defining-Analysis-Methods","page":"REPL","title":"Defining Analysis Methods","text":"","category":"section"},{"location":"repl/#Simple-Geochronology","page":"REPL","title":"Simple Geochronology","text":"KJ implements two types of methods Gmethod for geochronology, and Cmethod for chemical concentration measurements. The simplest definition of a Gmethod requires just the name of the geochronometer of interest:\n\nUPb_method = Gmethod(name=\"U-Pb\")\n\nAdditional arguments can be used to specify the prefixes of reference materials as groups. Prefixes that are missing from this Dict will be treated as samples. For example, suppose that a run uses two primary reference materials: Plesovice and 91500; which are labelled as STDCZ and 91500, respectively:\n\nUPb_method = Gmethod(name=\"U-Pb\", \n                     groups=Dict(\"STDCZ\" => \"Plesovice\", \"91500\" => \"91500\"),\n                     standards=Set([\"STDCZ\",\"91500\"]))\n\nThe .csv files with raw data contain column headers (\"channels\") that correspond to different mass-to-charge ratios in the mass spectrometer. For the U-Pb dataset shown above, it is easy to match these column headers with the geochronologically relevant isotopes (\"U238\", \"Pb206\" and \"Pb207\"). This is not always the case. In the case of &beta;-chronometry (Lu-Hf, Re-Os, K-Ca, Rb-Sr), the column headers include chemical information that is not so easy for KJ to disentangle. These methods are based on the following age equation:\n\nfracDd = leftfracDdright_0 + fracPd left(e^lambda t - 1right)\n\nwhere P, D and d refer to the radioactive \"parent\", radiogenic \"daughter\" and non-radiogenic \"sister\" isotope. An additional complexity arises because P and d are often measured by proxy, using a different isotope. These complexities are accommodated by providing the Gmethod constructor with Pairings:\n\nLuHf_method = Gmethod(name=\"Lu-Hf\",\n                      groups=Dict(\"hogsbo\" => \"Hogsbo\", \"NIST612p\" => \"NIST612\"),\n                      P=Pairing(ion=\"Lu176\", proxy=\"Lu175\", channel=\"Lu175 -> 175\"),\n                      D=Pairing(ion=\"Hf176\", channel=\"Hf176 -> 258\"),\n                      d=Pairing(ion=\"Hf177\", proxy=\"Hf178\", channel=\"Hf178 -> 260\"),\n                      standards=Set([\"hogsbo\"]))","category":"section"},{"location":"repl/#Advanced-Geochronology","page":"REPL","title":"Advanced Geochronology","text":"Add a mass bias correction for <sup>176</sup>Hf/<sup>178</sup>Hf based on the known ratio of NIST-612 standard glass, and a correction for the isobaric interference of <sup>176</sup>Lu on <sup>176</sup>Hf, measured by proxy using the reaction products of <sup>175</sup>Lu and the known <sup>176</sup>Lu/<sup>175</sup>Lu ratio of the Solar System:\n\nCalibration!(LuHf_method; standards=Set([\"NIST612p\"]))\nLuHf_method.D.interferences[\"Lu176\"] = Interference(proxy=\"Lu175\", channel=\"Lu175 -> 257\")\n\nA Re-Os example with complex interferences, including:\n\nan elemental fractionation correction using QMolyHill molybdenite as a primary reference material\na mass bias correction for <sup>187</sup>Os/<sup>188</sup>Os measured in the NiS-3 reference material\nan interference correction of <sup>187</sup>Re on <sup>187</sup>Os measured using NIST-610 glass\na Rare Earth interference of TmO on <sup>185</sup>Re, using LuO/Lu ratio as a proxy\n\nReOs_method = Gmethod(name=\"Re-Os\",\n                      groups=Dict(\"Nis3\" => \"NiS-3\",\n                                  \"Nist_massbias\" => \"NIST610\",\n                                  \"Nist_REEint\" => \"NIST610\",\n                                  \"Qmoly\" => \"QMolyHill\"),\n                      P=Pairing(ion=\"Re187\", proxy=\"Re185\", channel=\"Re185 -> 185\"),\n                      D=Pairing(ion=\"Os187\", channel=\"Os187 -> 251\"),\n                      d=Pairing(ion=\"Os188\", proxy=\"Os189\", channel=\"Os189 -> 253\"),\n                      standards=Set([\"Qmoly\"]))\nCalibration!(ReOs_method;standards=Set([\"Nis3\"]))\nRe_bias = Calibration(num=(ion=\"Re187\",channel=\"Os187 -> 251\"),\n                      den=(ion=\"Re185\",channel=\"Re185 -> 249\"),\n                      standards=Set([\"Nist_massbias\"]))\nReOs_method.D.interferences[\"Re187\"] = Interference(proxy=\"Re185\",\n                                                    channel=\"Re185 -> 249\",\n                                                    bias=Re_bias)\nReOs_method.P.interferences[\"Tm169 -> 185\"] = REEInterference(REE=\"Lu175 -> 191\",\n                                                              REEO=\"Ir191 -> 191\",\n                                                              standards=Set([\"Nist_REEint\"]))","category":"section"},{"location":"repl/#Concentrations","page":"REPL","title":"Concentrations","text":"To measure elemental concentration, KJ uses stoichiometric elements as internal references. It then compares all other elements with this internal standard, and with a concentration standard such as NIST glass:\n\nmap_method = Cmethod(map_run;\n                     groups=Dict(\"NIST612\" => \"NIST612\"),\n                     internal=getInternal(\"zircon\",\"Si29\"))","category":"section"},{"location":"repl/#Processing-Data","page":"REPL","title":"Processing Data","text":"","category":"section"},{"location":"repl/#Selection-Windows","page":"REPL","title":"Selection Windows","text":"A typical laser ablation analysis consists of three phases:\n\nan initial phase in which the laser fires into a shutter whilst the ICP-MS measures the background\nopening of the shutter (\"time zero\") followed by the measurements of the signal\nswitching off the laser and washout of the signal from the tubing of the instrument\n\nKJ aims to automatically partition these measurements into these three phases. However, the user can also manually override its decisions. To view the windows for the second sample in the Lu-Hf run:\n\nsample_index = 2\np = KJ.plot(LuHf_run[sample_index];\n            channels=[\"Hf176 -> 258\", \"Hf178 -> 260\"])\ndisplay(p)\n\nNow change the blank window for all the samples from 0 to 22 seconds:\n\nsetBwin!(LuHf_run, [(0,22)]; seconds=true)\n\nCreate a two-part signal window for the selected sample:\n\nsetSwin!(LuHf_run[sample_index], [(70,90), (100,140)])\n\nAutomatically set the background and signal windows for all samples:\n\nsetBwin!(LuHf_run)\nsetSwin!(LuHf_run)","category":"section"},{"location":"repl/#Basic-Processing","page":"REPL","title":"Basic Processing","text":"Process the entire dataset with a single command. This automatically places samples into the correct groups, applies corrections for background, interferences and mass bias, before parameterising the elemental fractionation.\n\nUPb_fit = process!(UPb_run, UPb_method)","category":"section"},{"location":"repl/#Visualisation","page":"REPL","title":"Visualisation","text":"","category":"section"},{"location":"repl/#Basic-Plotting","page":"REPL","title":"Basic Plotting","text":"Plot the first sample of the LuHf run with specified channels:\n\np = KJ.plot(LuHf_run[1]; channels=[\"Hf176 -> 258\", \"Hf178 -> 260\"])\ndisplay(p)\n\nTake ratios and plot on a log scale:\n\np = KJ.plot(LuHf_run[1];\n            channels=[\"Lu175 -> 175\", \"Hf176 -> 258\", \"Hf178 -> 260\"],\n            den=\"Hf178 -> 260\",\n            transformation=\"log\")\ndisplay(p)","category":"section"},{"location":"repl/#Processing-Results","page":"REPL","title":"Processing Results","text":"The output of process! can be added to the plot for the reference materials. This allows a visual inspection of the goodness-of-fit:\n\np = KJ.plot(UPb_run[2], UPb_method; fit=UPb_fit,\n            transformation=\"log\")\ndisplay(p)","category":"section"},{"location":"repl/#Specialised-Plots","page":"REPL","title":"Specialised Plots","text":"One of the unique features of KJ is its ability to fit internal isochrons based on time resolved atomic abundance estimates. This can be used to correct the non-radiogenic component of individual crystals without the need to assume an isochron intercept. Applying this idea to a laser ablation line across a large garnet:\n\nlines_run = load(\"data/lines\",format=\"Agilent\")\nlines_method = Gmethod(name=\"Lu-Hf\",\n                       groups=Dict(\"Hog\" => \"Hogsbo\"),\n                       P=Pairing(ion=\"Lu176\",proxy=\"Lu175\",channel=\"Lu175 -> 175\"),\n                       D=Pairing(ion=\"Hf176\",proxy=\"Hf176\",channel=\"Hf176 -> 258\"),\n                       d=Pairing(ion=\"Hf177\",proxy=\"Hf178\",channel=\"Hf178 -> 260\"),\n                       standards=Set([\"Hog\"]),\n                       ndown=0,\n                       ndrift=1)\nlines_fit = process!(lines_run,lines_method)\np = internoplot(lines_run[7],lines_method,lines_fit)\ndisplay(p)\n\nKJ also provides very simple functionality to plot elemental concentration maps:\n\nmap_fit = process!(map_run,map_method)\nconc = concentrations(map_run[10],map_method,map_fit)\np = plotMap(conc,\"ppm[U] from U238\";\n            clims=(0,500),\n            colorbar_scale=:identity)\ndisplay(p)\n\nThe output of the concentrations(...) function can also be saved to a data frame or output file for more sophisticated plotting in other Julia packages, or in external software:\n\nusing DataFrames\ndf = DataFrame(a)","category":"section"},{"location":"repl/#Outlier-Detection","page":"REPL","title":"Outlier Detection","text":"By default, KJ automatically identifies \"spikes\" in the time resolved data, using a multivariate outlier detection algorithm that fits a multivariate normal distribution to the raw data using the robust minimum covariance determinant (MCD) estimation method. Given this fitted distribution, outliers are flagged by applying \"Tukey's fences\" to the Mahalanobis distance. Applying this algorithm to some K-Ca data:\n\nchannels = [\"K39 -> 39\", \"Ca40 -> 59\", \"Ca44 -> 63\"]\ndetect_outliers!(KCa_run; include_samples=true, channels=channels)\np = KJ.plot(KCa_run[1]; channels=channels, transformation=\"log\")\ndisplay(p)","category":"section"},{"location":"repl/#Data-Analysis-and-Statistics","page":"REPL","title":"Data Analysis and Statistics","text":"","category":"section"},{"location":"repl/#Estimate-atomic-abundances","page":"REPL","title":"Estimate atomic abundances","text":"KJ converts the time resolved signals (which can be recorded in V, A or Hz) to time resolved estimates of atomic abundances in arbitrary units. This low level output can be extracted from KJ and processed in Julia or other software.\n\nusing Plots\na = atomic(LuHf_run[1],LuHf_method,LuHf_fit)\np = Plots.scatter(a.D,a.d,label=\"\",xlabel=\"P\",ylabel=\"d\")\ndisplay(p)","category":"section"},{"location":"repl/#Extract-Isotopic-Ratios","page":"REPL","title":"Extract Isotopic Ratios","text":"Compute mean isotopic ratios for all samples:\n\nusing CSV\nLuHf_fit = process!(LuHf_run, LuHf_method)\nLuHf_ratios = averat(LuHf_run, LuHf_method, LuHf_fit)\nselection = prefix2subset(LuHf_ratios, \"hogsbo\")\nCSV.write(\"output/hogsbo.csv\",selection)","category":"section"},{"location":"repl/#Internal-Isochron-Calculation","page":"REPL","title":"Internal Isochron Calculation","text":"Save the ages and intercepts of all internal isochrons in LuHf_run to a .csv file:\n\nisochron = internochron(LuHf_run, LuHf_method, LuHf_fit)\nCSV.write(\"output/isochron.csv\", isochron)","category":"section"},{"location":"repl/#Exporting-to-IsoplotR","page":"REPL","title":"Exporting to IsoplotR","text":"Export the U-Pb results for use in IsoplotR:\n\nexport2IsoplotR(UPb_run, UPb_method, UPb_fit; fname=\"output/U-Pb.json\")\n\nSelect specific samples with a prefix filter:\n\nexport2IsoplotR(UPb_run, UPb_method, UPb_fit;\n                prefix=\"GJ1\",\n                fname=\"output/GJ1.json\")\n\nExport pre-computed ratios:\n\nexport2IsoplotR(LuHf_ratios, LuHf_method; fname=\"output/Lu-Hf.json\")\n\nFor detailed function documentation, see the API reference.","category":"section"},{"location":"#KJ.jl","page":"Home","title":"KJ.jl","text":"KJ (\"Kasper Julia\") is a Julia package for LA-ICP-MS data reduction (Laser Ablation Inductively Coupled Plasma Mass Spectrometry).","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"First, ensure Julia is installed. Then at the Julia REPL:\n\nimport Pkg; Pkg.add(url=\"https://github.com/pvermees/KJ.jl.git\")\n\nOptionally, precompile the package for faster startup:\n\nPkg.precompile(\"KJ\")\n\nThere are two main ways to interact with KJ: a text-based user interface (TUI) and a \"read-eval-print loop\" (REPL).","category":"section"},{"location":"#Text-Based-User-Interface-(TUI)","page":"Home","title":"Text-Based User Interface (TUI)","text":"KJ provides an interactive text-based user interface for data processing workflows.\n\nusing KJ\nTUI()\n\nThis launches an interactive menu where you can:\n\nLoad LA-ICP-MS data files\nSpecify analysis methods\nView and adjust samples\nSet interferences and fractionation corrections\nProcess data and export results\n\nSee the TUI documentation for further details.","category":"section"},{"location":"#Command-Line-Interface-(REPL)","page":"Home","title":"Command-Line Interface (REPL)","text":"Advanced users can use Julia's command-line interface for direct scripting and analysis control. Here is a simple example of a U-Pb data processing session using test data that is packaged with KJ:\n\nusing KJ\n\n# Load LA-ICP-MS data\nmyrun = load(\"data/U-Pb\"; format=\"Agilent\", head2name=false)\n\n# Define the analysis method\nmethod = Gmethod(name=\"U-Pb\", groups=Dict(\"STDCZ\" => \"Plesovice\"))\n\n# Process the data\nfit = process!(myrun, method)\n\n# Export results to IsoplotR format\nexport2IsoplotR(myrun, method, fit; fname=\"output/U-Pb.json\")\n\nType ?load, ?process!, ?export2IsoplotR, or ?KJ at the REPL for detailed documentation.\n\nFurther examples are provided in the REPL documentation.","category":"section"},{"location":"#Hybrid:-TUI-REPL","page":"Home","title":"Hybrid: TUI + REPL","text":"You can seamlessly switch between the TUI and REPL. From the TUI, press x twice to exit and return to the Julia REPL:\n\njulia> TUI()\n# ... use TUI ...\n# press 'x' to exit\n\njulia> ctrl = getKJctrl()\njulia> samp = ctrl[\"run\"][1]\njulia> plot(samp)\n\nYou can also synchronize changes made in the REPL back to the TUI:\n\njulia> setKJctrl!(ctrl)\njulia> TUI()  # Resume with updated settings\n\nSeamlessly switch between the TUI and REPL. Store TUI settings into a variable and manipulate them programmatically using getKJctrl() and setKJctrl!() functions.\n\nFurther information about KJ's software architecture is provided in the Developer section of this document.\n\nSee the API documentation for complete function reference.","category":"section"},{"location":"developers/#Developers","page":"Developers","title":"Developers","text":"This section provides further details about the internal structure of KJ.","category":"section"},{"location":"developers/#Types","page":"Developers","title":"Types","text":"","category":"section"},{"location":"developers/#Global-settings","page":"Developers","title":"Global settings","text":"","category":"section"},{"location":"developers/#Key-functions","page":"Developers","title":"Key functions","text":"","category":"section"},{"location":"developers/#TUI-design","page":"Developers","title":"TUI design","text":"","category":"section"}]
}
